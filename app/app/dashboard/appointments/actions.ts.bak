"use server";

import { createClient } from "@/utils/supabase/server";
import { Tables, Database } from "@/types/database.types";

/**
 * Debug function to list all cases in the database
 * This helps troubleshoot issues with case creation and syncing
 */
export async function debugListAllCases() {
  try {
    console.log("*** DEBUG: Listing all cases in database ***");
    const supabase = await createClient();

    // Get all cases sorted by id (safer if created_at doesn't exist)
    const { data: cases, error } = await supabase
      .from("cases")
      .select("*")
      .order("id", { ascending: false })
      .limit(20);

    if (error) {
      console.error(
        "Error fetching all cases in debugListAllCases:",
        JSON.stringify(error)
      );
      return [];
    }

    console.log(`Found ${cases.length} cases:`, JSON.stringify(cases, null, 2));
    return cases as Tables["cases"]["Row"][];
  } catch (error) {
    console.error("Exception in debugListAllCases:", error);
    return [];
  }
}

interface AppointmentQueryResult {
  id: string;
  visibility: Database["public"]["Enums"]["CaseVisibility"] | null;
  type: string | null;
  status: Database["public"]["Enums"]["CaseStatus"] | null;
  created_at: string;
  updated_at: string | null;
  patients:
    | {
        id: string;
        name: string | null;
        owner_name: string | null;
      }[]
    | null;
  transcriptions: { id: string }[] | null;
  soap_notes: { id: string }[] | null;
  generations: { id: string }[] | null;
}

interface AppointmentResult {
  appointments: Array<{
    id: string;
    patientName: string;
    ownerName: string;
    type: string;
    date: string;
    time: string;
    status: string;
    hasTranscription: boolean;
    hasSoapNote: boolean;
    hasGeneration: boolean;
  }>;
  totalCount: number;
  page: number;
  pageSize: number;
}

/**
 * Get appointments with filtering and pagination
 * This is the main function used in the appointments table view
 */
export async function getAppointments({
  page = 0,
  pageSize = 10,
  searchQuery = "",
  dateFilter = "",
  timestamp = Date.now(),
  forceRefresh = false,
}: {
  page?: number;
  pageSize?: number;
  searchQuery?: string;
  dateFilter?: string;
  timestamp?: number;
  forceRefresh?: boolean;
} = {}): Promise<AppointmentResult> {
  try {
    console.log("Server action: getAppointments called with params:", {
      page,
      pageSize,
      searchQuery,
      dateFilter,
      timestamp,
    });
    const supabase = await createClient();

    // Calculate pagination
    const from = page * pageSize;
    const to = from + pageSize - 1;

    // First, build the query to fetch cases with related patient data
    let query = supabase
      .from("cases")
      .select(
        `
        id,
        visibility,
        type,
        status,
        created_at,
        updated_at,
        patients (
          id,
          name,
          owner_name
        ),
        transcriptions (
          id
        ),
        soap_notes (
          id
        ),
        generations (
          id
        )
      `
      )
      .order("created_at", { ascending: false });

    // Add console log to debug the query
    console.log("Fetching cases with query parameters:", {
      page,
      pageSize,
      searchQuery,
      dateFilter,
    });

    // Apply search filter if provided
    if (searchQuery) {
      // Search in patients table since name is now there
      query = query.or(`
        patients.name.ilike.%${searchQuery}%,
        type.ilike.%${searchQuery}%
      `);
    }

    // Apply date filter if provided
    if (dateFilter) {
      try {
        // Convert dateFilter to start and end of day
        const startOfDay = `${dateFilter}T00:00:00.000Z`;
        const endOfDay = `${dateFilter}T23:59:59.999Z`;

        // Log for debugging
        console.log("Filtering by date range:", {
          startOfDay,
          endOfDay,
          dateFilter,
        });

        // Use created_at instead of dateTime
        query = query.gte("created_at", startOfDay).lte("created_at", endOfDay);
      } catch (error) {
        console.error("Error setting date filter:", error);
      }
    }

    // Execute the query with pagination
    const { data: casesData, error: casesError } = await query.range(from, to);

    if (casesError) {
      console.error("Error fetching cases:", casesError);
      throw new Error(casesError.message);
    }

    // Debug the results
    console.log(
      `Found ${casesData ? casesData.length : 0} cases in the database`
    );
    if (casesData && casesData.length > 0) {
      console.log("Sample case data:", JSON.stringify(casesData[0], null, 2));
    }

    // Get total count for pagination
    const { count: totalCount, error: countError } = await supabase
      .from("cases")
      .select("id", { count: "exact", head: true });

    if (countError) {
      console.error("Error getting count:", countError);
    }

    // Map cases to appointments format
    let appointments = [];

    if (casesData && casesData.length > 0) {
      // Map cases to appointments format
      appointments = casesData
        .map((caseItem: AppointmentQueryResult) => {
          try {
            // Get the first patient from the patients array
            const patient =
              caseItem.patients && caseItem.patients.length > 0
                ? caseItem.patients[0]
                : null;

            // Format the date and time from created_at
            const dateTime = new Date(caseItem.created_at);
            const formattedDate = dateTime.toLocaleDateString();
            const formattedTime = dateTime.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });

            return {
              id: caseItem.id,
              patientName: patient?.name || "Unknown Patient",
              ownerName: patient?.owner_name || "Unknown Owner",
              type: caseItem.type || "General",
              date: formattedDate,
              time: formattedTime,
              status: caseItem.status || "ongoing",
              hasTranscription:
                caseItem.transcriptions && caseItem.transcriptions.length > 0,
              hasSoapNote:
                caseItem.soap_notes && caseItem.soap_notes.length > 0,
              hasGeneration:
                caseItem.generations && caseItem.generations.length > 0,
            };
          } catch (error) {
            console.error("Error mapping case to appointment:", error);
            return null;
          }
        })
        .filter(Boolean); // Remove any null items from failed mappings
    }

    return {
      appointments,
      totalCount: totalCount || 0,
      page,
      pageSize,
    };
  } catch (error) {
    console.error("Server action error in getAppointments:", error);
    // Return empty data rather than throwing
    return {
      appointments: [],
      totalCount: 0,
      page: 0,
      pageSize,
    };
  }
}